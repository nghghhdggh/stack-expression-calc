Индивидуальное задание: вычисление выражения через стек

Пушкарев Сергей ИТ-8

Постановка задачи: Используя структуру стека, вычислить выражение, содержащее две операции: поиск минимума (обозначается m(<число1>,<число2>)) и поиск максимума (обозначается M(<число1>,<число2>)). Операции могут быть вложенными, например, M(15, m(16,8)) (в данном выражении ищем минимум из 16 и 8, а потом ищем максимум от результата m(16,8) и 15, ответ 15). В качестве аргументов могут использоваться только целые положительные числа. Строка, вводимая пользователем, корректна и не содержит пробелов.

Реализация и выбранные структуры данных:
- Класс Stack
- Класс MathOperations с ручными методами min/max
- Разбор строки и стековая обработка
- Обработка ошибок через пользовательское исключение

Используемые принципы ООП:
- Инкапсуляция (в Stack)
- Наследование (StackEmptyError)
- Полиморфизм (обработка m и M через метод)
- Исключения (контроль пустого стека)

Листинг:
class StackEmptyError(Exception): # класс исключения для создания собственного типа ошибки
    pass


class Stack: # класс стека
    def __init__(self):
        self._items = [] # хранение элементов стека

    def push(self, item):
        self._items.append(item) # добавление элемента в стек

    def pop(self):
        if self.is_empty():
            raise StackEmptyError("Попытка извлечь элемент из пустого стека.")
        return self._items.pop() # извлечение элемента из стека

    def peek(self):
        if self.is_empty():
            raise StackEmptyError("Попытка посмотреть верхушку пустого стека.")
        return self._items[-1] # просмотр верхнего элемента

    def is_empty(self):
        return len(self._items) == 0 # проверка стека на пустоту

    def size(self):
        return len(self._items) # размер стека


class MathOperations: # класс для нахождения минимума/максимума
    @staticmethod # декоратор для того, чтобы можно было использовать функцию без создания экземпляра класса
    def custom_min(a, b):
        if a < b:
            return a
        return b

    @staticmethod
    def custom_max(a, b):
        if a > b:
            return a
        return b


class ExpressionEvaluator: # класс для вычисления выражения из стека
    def __init__(self, expression):
        self.expression = expression # сохранение строки
        self.stack = Stack() # инициализация стека

    def evaluate(self):
        i = 0
        while i < len(self.expression): # посимвольное чтение строки
            char = self.expression[i]
            if char.isdigit(): # если символ - число
                num = ''
                while i < len(self.expression) and self.expression[i].isdigit(): # собираем число целиком
                    num += self.expression[i]
                    i += 1
                self.stack.push(int(num)) # добавляем число в стек
                continue
            elif char in ('m', 'M', '(', ',', ')'):
                self.stack.push(char)
            i += 1

        return self._process_stack() # обработка стека

    def _process_stack(self):
        temp_stack = Stack()

        while not self.stack.is_empty(): # рассматриваем стек в обратном порядке
            token = self.stack.pop()
            temp_stack.push(token)

        return self._evaluate_tokens(temp_stack) # обработка стека

    def _evaluate_tokens(self, tokens):
        while tokens.size() > 1:
            temp = Stack()
            while not tokens.is_empty():
                token = tokens.pop()
                if token == ')': # если нашли закрывающую скобку, начинаем собирать выражение
                    arg2 = temp.pop()
                    comma = temp.pop()
                    arg1 = temp.pop()
                    open_bracket = temp.pop()
                    func = temp.pop()

                    if func == 'm':
                        result = MathOperations.custom_min(arg1, arg2)
                    elif func == 'M':
                        result = MathOperations.custom_max(arg1, arg2)
                    else:
                        raise ValueError(f"Неизвестная операция: {func}")

                    temp.push(result) # результат операции добавляем обратно в стек
                else:
                    temp.push(token)

            tokens = temp

        return tokens.pop()


if __name__ == "__main__":
    try:
        expression = input("Введите выражение (например, M(15,m(16,8))): ")
        evaluator = ExpressionEvaluator(expression)
        result = evaluator.evaluate()
        print(f"Результат: {result}")
    except Exception as e:
        print(f"Ошибка: {e}")

Тесты:
Ввод: M(15,m(16,8))
Результат: 15
